<?php

declare(strict_types=1);

namespace SignerPHP\Tests\Unit;

use SignerPHP\Application\DTO\ProtectionOptionsDto;
use SignerPHP\Domain\Exception\ProtectionProcessException;
use SignerPHP\Infrastructure\Native\Contract\CommandExecutorInterface;
use SignerPHP\Infrastructure\Native\Service\NativeFunctionOverrideState;
use SignerPHP\Infrastructure\Native\Service\QpdfPdfProtectionApplier;
use PHPUnit\Framework\TestCase;

final class QpdfPdfProtectionApplierTest extends TestCase
{
    public function test_apply_builds_expected_qpdf_command_and_returns_protected_content(): void
    {
        $capture = new class
        {
            public ?string $command = null;
        };

        $executor = new class($capture) implements CommandExecutorInterface
        {
            public function __construct(private object $capture) {}

            public function run(string $command, string $errorMessage): void
            {
                $this->capture->command = $command;

                preg_match_all("/'([^']+)'/", $command, $matches);
                $quotedArgs = $matches[1];
                $outputFile = end($quotedArgs);
                file_put_contents((string) $outputFile, 'protected-pdf-content');
            }
        };

        $applier = new QpdfPdfProtectionApplier($executor);
        $result = $applier->apply(
            'input-pdf-content',
            new ProtectionOptionsDto(
                ownerPassword: 'owner-secret',
                userPassword: 'user-secret',
                allowPrint: false,
                allowCopy: false,
                allowModify: false,
                keyLengthBits: 128,
                encryptMetadata: false,
            )
        );

        self::assertSame('protected-pdf-content', $result);
        self::assertNotNull($capture->command);
        self::assertStringContainsString('qpdf --encrypt', $capture->command);
        self::assertStringContainsString("--encrypt 'user-secret' 'owner-secret' 128", $capture->command);
        self::assertStringContainsString('--print=none', $capture->command);
        self::assertStringContainsString('--extract=n', $capture->command);
        self::assertStringContainsString('--modify=none', $capture->command);
        self::assertStringContainsString('--cleartext-metadata', $capture->command);
        self::assertStringContainsString('--use-aes=y', $capture->command);
    }

    public function test_apply_throws_when_protected_output_is_empty(): void
    {
        $executor = new class implements CommandExecutorInterface
        {
            public function run(string $command, string $errorMessage): void
            {
                // no output written intentionally
            }
        };

        $applier = new QpdfPdfProtectionApplier($executor);

        $this->expectException(ProtectionProcessException::class);
        $this->expectExceptionMessage('Could not read protected PDF content generated by qpdf');
        $applier->apply('input-pdf-content', new ProtectionOptionsDto(ownerPassword: 'owner-secret'));
    }

    public function test_apply_throws_when_temp_file_creation_fails(): void
    {
        NativeFunctionOverrideState::$forceTempnamFailure = true;

        try {
            $applier = new QpdfPdfProtectionApplier(new class implements CommandExecutorInterface
            {
                public function run(string $command, string $errorMessage): void {}
            });

            $this->expectException(ProtectionProcessException::class);
            $this->expectExceptionMessage('Could not create temporary files for PDF protection.');
            $applier->apply('input-pdf-content', new ProtectionOptionsDto(ownerPassword: 'owner-secret'));
        } finally {
            NativeFunctionOverrideState::$forceTempnamFailure = false;
        }
    }
}
