<?php

declare(strict_types=1);

namespace SignerPHP\Infrastructure\Native\Service;

use SignerPHP\Application\DTO\TimestampOptionsDto;
use SignerPHP\Domain\Exception\SignProcessException;
use SignerPHP\Infrastructure\Native\Contract\HttpClientInterface;
use SignerPHP\Infrastructure\Native\Contract\ProcessRunnerInterface;
use SignerPHP\Infrastructure\Native\Contract\TimestampTokenProviderInterface;

final class OpenSslRfc3161TimestampTokenProvider implements TimestampTokenProviderInterface
{
    /**
     * @var array<string, array{token:string,expiresAt:int}>
     */
    private static array $oauthTokenCache = [];

    public function __construct(
        private readonly HttpClientInterface $httpClient = new CurlHttpClient,
        private readonly ProcessRunnerInterface $processRunner = new ShellProcessRunner,
    ) {}

    public function requestTokenHex(string $signableDocument, array $byteRange, TimestampOptionsDto $options): string
    {
        $toTimestamp = $this->extractByteRangeData($signableDocument, $byteRange);

        $tmpDir = sys_get_temp_dir();
        $input = $this->createTempFile($tmpDir, 'tsa-input');
        $query = $this->createTempFile($tmpDir, 'tsa-query');
        $reply = $this->createTempFile($tmpDir, 'tsa-reply');
        $token = $this->createTempFile($tmpDir, 'tsa-token');

        file_put_contents($input, $toTimestamp);

        try {
            $this->runOpenSslQueryCommand($options, $input, $query);
            $this->requestTimestampReply($options, $query, $reply);
            $this->runOpenSslTokenCommand($reply, $token);

            $tokenContent = file_get_contents($token);
            if ($tokenContent === false || $tokenContent === '') {
                throw new SignProcessException('Could not read timestamp token generated by OpenSSL.');
            }

            $hex = current(unpack('H*', $tokenContent));
            if (! is_string($hex) || $hex === '') {
                throw new SignProcessException('Could not convert timestamp token to hex.');
            }

            return strtoupper($hex);
        } finally {
            @unlink($input);
            @unlink($query);
            @unlink($reply);
            @unlink($token);
        }
    }

    /**
     * @param  array{0:int,1:int,2:int,3:int}  $byteRange
     */
    private function extractByteRangeData(string $document, array $byteRange): string
    {
        [$offset1, $length1, $offset2, $length2] = $byteRange;

        return substr($document, $offset1, $length1).substr($document, $offset2, $length2);
    }

    private function createTempFile(string $tmpDir, string $prefix): string
    {
        $path = tempnam($tmpDir, $prefix);
        if ($path === false) {
            throw new SignProcessException('Could not create temporary file for timestamp processing.');
        }

        return $path;
    }

    private function runOpenSslQueryCommand(TimestampOptionsDto $options, string $inputFile, string $queryFile): void
    {
        $algorithmFlag = '-'.$this->normalizeHashAlgorithm($options->hashAlgorithm->value);
        $certReqFlag = $options->certReq ? ' -cert' : '';

        $cmd = sprintf(
            'openssl ts -query -data %s %s%s -out %s',
            escapeshellarg($inputFile),
            $algorithmFlag,
            $certReqFlag,
            escapeshellarg($queryFile)
        );

        $this->runCommand($cmd, 'Could not build RFC3161 query using OpenSSL.');
    }

    private function requestTimestampReply(TimestampOptionsDto $options, string $queryFile, string $replyFile): void
    {
        $query = file_get_contents($queryFile);
        if ($query === false) {
            throw new SignProcessException('Could not read generated RFC3161 query file.');
        }

        $headers = [
            'Content-Type: application/timestamp-query',
            'Accept: application/timestamp-reply',
            'Content-Length: '.strlen($query),
        ];

        if ($options->oauthClientId !== null && $options->oauthClientSecret !== null && $options->oauthTokenUrl !== null) {
            $headers[] = 'Authorization: Bearer '.$this->requestOAuthBearerToken($options);
        } elseif ($options->username !== null && $options->password !== null) {
            $headers[] = 'Authorization: Basic '.base64_encode($options->username.':'.$options->password);
        }

        $response = $this->httpClient->request(
            'POST',
            $options->tsaUrl,
            $headers,
            $query,
            $options->timeoutSeconds
        );
        if (($response->statusCode !== 200 && $response->statusCode !== 201) || $response->body === '') {
            $bodySnippet = trim(substr($response->body, 0, 240));
            throw new SignProcessException(sprintf(
                'Could not fetch RFC3161 timestamp response from TSA endpoint. Status: %d. Transport error: %s. Body: %s',
                $response->statusCode,
                $response->transportError ?? 'none',
                $bodySnippet !== '' ? $bodySnippet : '[empty]',
            ));
        }

        file_put_contents($replyFile, $response->body);
    }

    private function requestOAuthBearerToken(TimestampOptionsDto $options): string
    {
        $cacheKey = hash('sha256', implode('|', [
            (string) $options->oauthTokenUrl,
            (string) $options->oauthClientId,
            (string) $options->oauthClientSecret,
        ]));
        $now = time();

        $cached = self::$oauthTokenCache[$cacheKey] ?? null;
        if ($cached !== null && $cached['expiresAt'] > ($now + 30)) {
            return $cached['token'];
        }

        $content = http_build_query([
            'grant_type' => 'client_credentials',
        ]);

        $headers = [
            'Content-Type: application/x-www-form-urlencoded',
            'Accept: application/json',
            'Authorization: Basic '.base64_encode($options->oauthClientId.':'.$options->oauthClientSecret),
            'Content-Length: '.strlen($content),
        ];

        $response = $this->httpClient->request(
            'POST',
            (string) $options->oauthTokenUrl,
            $headers,
            $content,
            $options->timeoutSeconds
        );
        if ($response->statusCode !== 200 || $response->body === '') {
            $bodySnippet = trim(substr($response->body, 0, 240));
            throw new SignProcessException(sprintf(
                'Could not fetch OAuth token from TSA auth endpoint. Status: %d. Transport error: %s. Body: %s',
                $response->statusCode,
                $response->transportError ?? 'none',
                $bodySnippet !== '' ? $bodySnippet : '[empty]',
            ));
        }

        $json = json_decode($response->body, true);
        if (! is_array($json) || ! isset($json['access_token']) || ! is_string($json['access_token']) || $json['access_token'] === '') {
            throw new SignProcessException('Invalid OAuth token response from TSA auth endpoint.');
        }

        $expiresIn = isset($json['expires_in']) && is_numeric($json['expires_in'])
            ? (int) $json['expires_in']
            : 3600;

        self::$oauthTokenCache[$cacheKey] = [
            'token' => $json['access_token'],
            'expiresAt' => $now + max($expiresIn, 60),
        ];

        return $json['access_token'];
    }

    private function runOpenSslTokenCommand(string $replyFile, string $tokenFile): void
    {
        $cmd = sprintf(
            'openssl ts -reply -in %s -token_out -out %s',
            escapeshellarg($replyFile),
            escapeshellarg($tokenFile)
        );

        $this->runCommand($cmd, 'Could not extract RFC3161 token from TSA response.');
    }

    private function runCommand(string $command, string $errorMessage): void
    {
        $result = $this->processRunner->run($command);
        if (! $result->succeeded()) {
            throw new SignProcessException($errorMessage.' '.$result->outputAsString());
        }
    }

    private function normalizeHashAlgorithm(string $hash): string
    {
        $normalized = strtolower(trim($hash));
        $allowed = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512'];
        if (! in_array($normalized, $allowed, true)) {
            throw new SignProcessException('Unsupported timestamp hash algorithm: '.$hash);
        }

        return $normalized;
    }
}
